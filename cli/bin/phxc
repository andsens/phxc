#!/usr/bin/env bash
# shellcheck source-path=..
set -eo pipefail; shopt -s inherit_errexit
PKGROOT=$(realpath "$(dirname "$(realpath "${BASH_SOURCE[0]}")")/..")
source "$PKGROOT/.upkg/records.sh/records.sh"

CONFIG_DIR=$HOME/.config/phxc
KUBE_API_SERVER_CA_CRT=$CONFIG_DIR/kube-api-server-ca.crt
KUBE_API_CLIENT_CA_CRT=$CONFIG_DIR/kube-api-client-ca.crt

main() {
  DOC="phxc - Phoenix Cluster management tool
Usage:
  phxc setup [-k KN -u UN] KUBEAPI_HOSTNAME
  phxc bootstrap [--wait] VARIANT
  phxc update-nodes (all | NODE...)
  phxc backup-secrets [FILE]
  phxc restore-secrets [FILE]
  phxc embed-configs IMAGE CLUSTER [NODE [RPIOTP]]
  phxc get-kube-cert [-k KN -u UN] KUBEAPI_HOSTNAME

Options:
  -u --username=UN     K8S username to authenticate as [default: system:admin]
  -k --ssh-keyname=KN  SSH key to use for authentication [default: \$USER@\$HOST]
  -w --wait            Wait for completion

Commands:
  setup           - Setup the Phoenix Cluster root trust and configure kubectl
  bootstrap       - Manually start a bootstrap job for VARIANT
  update-node     - Update the node with the latest bootstrapped image
  backup-secrets  - Backup the phxc-ca and secureboot certs & keys
  restore-secrets - Restore the phxc-ca and secureboot certs & keys
  embed-configs   - Embed configuration in the FAT32 partition of a disk image
  get-kube-cert   - Issue or refresh a client cert for use with kubectl
"
# docopt parser below, refresh this parser with `docopt.sh phxc`
# shellcheck disable=2016,2086,2317,1090,1091,2034,2154
docopt() { local v='2.0.2'; source \
"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh" "$v" || { ret=$?;printf -- "exit \
%d\n" "$ret";exit "$ret";};set -e;trimmed_doc=${DOC:0:1043};usage=${DOC:39:282}
digest=1fdaf;options=('-k --ssh-keyname 1' '-u --username 1' '-w --wait 0')
node_0(){ value __ssh_keyname 0;};node_1(){ value __username 1;};node_2(){
switch __wait 2;};node_3(){ value KUBEAPI_HOSTNAME a;};node_4(){ value VARIANT a
};node_5(){ value NODE a true;};node_6(){ value FILE a;};node_7(){ value IMAGE a
};node_8(){ value CLUSTER a;};node_9(){ value RPIOTP a;};node_10(){ switch \
setup a:setup;};node_11(){ switch bootstrap a:bootstrap;};node_12(){ switch \
update_nodes a:update-nodes;};node_13(){ switch all a:all;};node_14(){ switch \
backup_secrets a:backup-secrets;};node_15(){ switch restore_secrets \
a:restore-secrets;};node_16(){ switch embed_configs a:embed-configs;};node_17(){
switch get_kube_cert a:get-kube-cert;};node_18(){ sequence 10 19 3;};node_19(){
optional 0 1;};node_20(){ sequence 11 21 4;};node_21(){ optional 2;};node_22(){
sequence 12 23;};node_23(){ choice 13 24;};node_24(){ repeatable 5;};node_25(){
sequence 14 26;};node_26(){ optional 6;};node_27(){ sequence 15 26;};node_28(){
sequence 16 7 8 29;};node_29(){ optional 5 9;};node_30(){ sequence 17 19 3;}
node_31(){ choice 18 20 22 25 27 28 30;};cat <<<' docopt_exit() { [[ -n $1 ]] \
&& printf "%s\n" "$1" >&2;printf "%s\n" "${DOC:39:282}" >&2;exit 1;}';local \
varnames=(__ssh_keyname __username __wait KUBEAPI_HOSTNAME VARIANT NODE FILE \
IMAGE CLUSTER RPIOTP setup bootstrap update_nodes all backup_secrets \
restore_secrets embed_configs get_kube_cert) varname;for varname in \
"${varnames[@]}"; do unset "var_$varname";done;parse 31 "$@";local \
p=${DOCOPT_PREFIX:-''};for varname in "${varnames[@]}"; do unset "$p$varname"
done;if declare -p var_NODE >/dev/null 2>&1; then eval $p'NODE=("${var_NODE[@]'\
'}")';else eval $p'NODE=()';fi;eval $p'__ssh_keyname=${var___ssh_keyname:-'\
"'"'$USER@$HOST'"'"'};'$p'__username=${var___username:-system:admin};'$p'__wai'\
't=${var___wait:-false};'$p'KUBEAPI_HOSTNAME=${var_KUBEAPI_HOSTNAME:-};'$p'VAR'\
'IANT=${var_VARIANT:-};'$p'FILE=${var_FILE:-};'$p'IMAGE=${var_IMAGE:-};'$p'CLU'\
'STER=${var_CLUSTER:-};'$p'RPIOTP=${var_RPIOTP:-};'$p'setup=${var_setup:-false'\
'};'$p'bootstrap=${var_bootstrap:-false};'$p'update_nodes=${var_update_nodes:-'\
'false};'$p'all=${var_all:-false};'$p'backup_secrets=${var_backup_secrets:-fal'\
'se};'$p'restore_secrets=${var_restore_secrets:-false};'$p'embed_configs=${var'\
'_embed_configs:-false};'$p'get_kube_cert=${var_get_kube_cert:-false};';local \
docopt_i=1;[[ $BASH_VERSION =~ ^4.3 ]] && docopt_i=2;for \
((;docopt_i>0;docopt_i--)); do for varname in "${varnames[@]}"; do declare -p \
"$p$varname";done;done;}
# docopt parser above, complete command for generating this parser is `docopt.sh --library='"$PKGROOT/.upkg/docopt-lib-v$v/docopt-lib.sh"' phxc`
  eval "$(docopt "$@")"

  export KUBECONFIG
  [ -n "$KUBECONFIG" ] || export KUBECONFIG="$HOME/.kube/config.yaml"
  grep -q "$HOME/.kube/phxc.yaml" <<<"$KUBECONFIG" || KUBECONFIG=$KUBECONFIG:$HOME/.kube/phxc.yaml

  [[ ! $KUBEAPI_HOSTNAME =~ ^(https?://)?([^:]+) ]] || KUBEAPI_HOSTNAME=${BASH_REMATCH[2]}
  [[ $__ssh_keyname != "\$USER@\$HOST" ]] || __ssh_keyname=$(id -un)@$(hostname)

  # shellcheck disable=SC2153,SC2154
  if $setup; then
    setup "$KUBEAPI_HOSTNAME" "$__ssh_keyname" "$__username"
  elif $get_kube_cert; then
    get_kube_client_cert "$KUBEAPI_HOSTNAME" "$__ssh_keyname" "$__username"
  elif $embed_configs; then
    embed_configs "$IMAGE" "$CLUSTER" "$NODE" "$RPIOTP"
  elif $backup_secrets; then
    backup_secrets "$FILE"
  elif $restore_secrets; then
    restore_secrets "$FILE"
  elif $bootstrap; then
    bootstrap "$VARIANT" "$__wait"
  elif $update_nodes; then
    nodes=()
    if $all; then
      # shellcheck disable=SC2207
      nodes=($(kubectl --context phxc get nodes -ojsonpath='{.items[*].metadata.name}'))
    else
      nodes=("${NODE[@]}")
    fi
    update_nodes "${nodes[@]}"
  fi
}

setup() {
  local kube_api_hostname=$1 ssh_keyname=$2 username=$3
  local yesno kube_api_server_ca_crt_fp kube_api_server_ca_crt_fp
  trap 'error "Failed to configure, run with LOGLEVEL=verbose to see more detailed errors"' ERR
  mkdir -p "$CONFIG_DIR"
  # TOFU for Kubernetes API Server CA
  kube_api_server_ca_crt=$(step certificate inspect --insecure --format pem "https://$kube_api_hostname:6443")
  kube_api_server_ca_crt_fp=$(step certificate fingerprint <(printf "%s\n" "$kube_api_server_ca_crt"))
  if [[ -e "$KUBE_API_SERVER_CA_CRT" ]]; then
    info "Checking existing Kubernetes API server CA certificate"
    local remote_kube_api_server_ca_crt_fp
    remote_kube_api_server_ca_crt_fp=$(step certificate fingerprint "$KUBE_API_SERVER_CA_CRT")
    if [[ $kube_api_server_ca_crt_fp != "$remote_kube_api_server_ca_crt_fp" ]]; then
      printf "Saved fingerprint:  %s\n" "$kube_api_server_ca_crt_fp" >&2
      printf "Remote fingerprint: %s\n" "$remote_kube_api_server_ca_crt_fp" >&2
      error "The saved Kubernetes API server CA certificate fingerprint does not match the one from the server!"
      [[ $(read -rp 'Are you sure you want to continue? [y/N]' yesno; echo "$yesno") =~ ^[Yy](es)?$ ]] || { trap '' ERR; fatal "User aborted operation"; }
    fi
  else
    warning "No trust has been established with this Kubernetes cluster yet.\nThe root certificate fingerprint is %s" "$kube_api_server_ca_crt_fp"
    [[ $(read -rp 'Do you want to establish that trust now? [y/N]' yesno; echo "$yesno") =~ ^[Yy](es)?$ ]] || { trap '' ERR; fatal "User aborted operation"; }
  fi
  printf "%s\n" "$kube_api_server_ca_crt" >"$KUBE_API_SERVER_CA_CRT"

  info "Downloading Kubernetes API Client CA certificate"
  curl -sk --no-progress-meter https://k8s-hyperv-1.local:9001/roots.pem >"$KUBE_API_CLIENT_CA_CRT"

  create_kube_config "$kube_api_hostname" "$ssh_keyname" "$username"

  trust_ssh_host_key
}

create_kube_config() {
  local kube_api_hostname=$1 ssh_keyname=$2 username=$3 kube_cfg_path=$HOME/.kube/phxc.yaml kube_context=phxc kube_cluster=phxc
  info "Setting up %s" "${kube_cfg_path//"$HOME"/"~"}"
  kubectl config --kubeconfig "$kube_cfg_path" set-cluster "$kube_cluster" \
    --server="https://$kube_api_hostname:6443" \
    --embed-certs \
    --certificate-authority="$KUBE_API_SERVER_CA_CRT"
  kubectl config --kubeconfig "$kube_cfg_path" set-credentials "$username@$kube_cluster" \
    --exec-api-version="client.authentication.k8s.io/v1beta1" \
    --exec-command="$(realpath "${BASH_SOURCE[0]}")" \
    --exec-arg="get-kube-cert" \
    --exec-arg="-k$ssh_keyname" \
    --exec-arg="-u$username" \
    --exec-arg="$kube_api_hostname"
  kubectl config --kubeconfig "$HOME/.kube/config.yaml" set-context $kube_context \
    --cluster "$kube_cluster" --user "$username@$kube_cluster"
  rm -f "$CONFIG_DIR/$username.crt" "$CONFIG_DIR/$username.key"
}

trust_ssh_host_key() {
  local trusted_certs=$HOME/.ssh/phxc_trusted_cert ssh_host_key
  info "Writing SSH host key trust to %s" "${trusted_certs//"$HOME"/"~"}"
  ssh_host_key=$(kubectl --context phxc -n smallstep get secret phxc-intermediate -ojsonpath='{.data.tls\.crt}' | \
    base64 -d | openssl x509 -noout -pubkey | ssh-keygen -f /dev/stdin -i -m PKCS8)
  printf "@cert-authority * %s\n" "$ssh_host_key" >"$trusted_certs"
}

get_kube_client_cert() {
  local kube_api_hostname=$1 ssh_keyname=$2 username=$3 cert key
  renew_kube_client_cert "$kube_api_hostname" "$ssh_keyname" "$username"
  cert=$(cat "$CONFIG_DIR/$username.crt")
  key=$(cat "$CONFIG_DIR/$username.key")
  printf '{
  "apiVersion": "client.authentication.k8s.io/v1beta1",
  "kind": "ExecCredential",
  "status": {
    "clientCertificateData": "%s",
    "clientKeyData": "%s"
  }
}
' "${cert//$'\n'/'\n'}" "${key//$'\n'/'\n'}"
}

renew_kube_client_cert() {
  local kube_api_hostname=$1 ssh_keyname=$2 username=$3 ca_url
  trap 'error "Failed to get certificate, run with LOGLEVEL=verbose to see more detailed errors"' ERR
  ca_url=https://${kube_api_hostname}:9001
  if [[ ! -e $CONFIG_DIR/$username.crt ]] || \
      step certificate needs-renewal --expires-in 0s "$CONFIG_DIR/$username.crt" 2>&1 | LOGPROGRAM=step pipe_verbose; then
    debug "Renewing client certificate"
    local ssh_pem admin_jwk kid header payload signature step_logs
    ssh_pem=$(step kms key "sshagentkms:$ssh_keyname" 2> >(LOGPROGRAM=step pipe_verbose))
    admin_jwk=$(step crypto jwk create --force --use sig --from-pem=<(printf "%s\n" "$ssh_pem") \
      /dev/stdout /dev/null 2> >(LOGPROGRAM=step pipe_verbose))
    kid=$(jq -r .kid <<<"$admin_jwk")
    header=$(jq '{
      "alg": .alg,
      "kid": .kid,
      "typ": "JWT"
    }' <<<"$admin_jwk" | jq -cS . | base64 -w0 | tr -d '=' | tr '/+' '_-')
    payload=$(jq -n --arg ca_url "$ca_url" --argjson now "$(date +%s)" --arg kid "$kid" \
                    --arg jti "$(openssl rand -hex 32)" --arg sub "$username" '{
      "aud": ($ca_url + "/1.0/sign"),
      "exp": ($now + 30),
      "iat": $now,
      "iss": $kid,
      "jti": $jti,
      "nbf": ($now - 30),
      "sans": [$sub],
      "sub": $sub
    }' | jq -cS . | base64 -w0 | tr -d '=' | tr '/+' '_-')
    signature=$(step kms sign --format jws --in <(printf "%s.%s" "$header" "$payload") \
      --kms "sshagentkms" "sshagentkms:$ssh_keyname")
    if ! step_logs=$(step ca certificate --ca-url="$ca_url" --root="$KUBE_API_CLIENT_CA_CRT" \
      --token="$header.$payload.$signature" --force \
      "$username" "$CONFIG_DIR/$username.crt" "$CONFIG_DIR/$username.key" 2>&1); then
      fatal "Failed to issue kube-api certificate:\n%s" "$step_logs"
    fi
  fi
}

embed_configs() {
  local image=$1 cluster=$2 node=$3 rpi_otp=$4 config_tmp
  config_tmp=$(mktemp -d --suffix '-phxc-embed-configs')
  # shellcheck disable=SC2064
  trap "rm -rf \"$config_tmp\"" EXIT
  # shellcheck disable=SC2154
  cp "$cluster" "$config_tmp/cluster.json"
  [[ -z $node ]] || cp "$node" "$config_tmp/node.json"
  [[ -z $rpi_otp ]] || cp "$rpi_otp" "$config_tmp/rpi-otp.json"
  local admin_ssh_key config_path
  admin_ssh_key=$(jq -r '.admin["ssh-keys"][0]' "$config_tmp/cluster.json")
  for config_path in "$config_tmp"/*; do
    ssh-keygen -Y sign -f <(printf "%s" "$admin_ssh_key") -n file "$config_path"
  done

  docker run --rm -ti \
    -v "$config_tmp:/workspace/embed-configs" \
    -v "$PKGROOT/scripts:/scripts:ro" \
    -v "$(realpath "$image"):/workspace/disk.img:rw" \
    -e "DEBUG=$DEBUG" \
    --device=/dev/kvm \
    --group-add "$(stat -c %g /dev/kvm)" \
    ghcr.io/andsens/phxc-embed-configs:sha-3e0c5ff
}

backup_secrets() {
  local dest=$1 backup
  backup=$(
    printf -- "# Phoenix Cluster secrets backup, restore with \`phxc restore secrets backup.yaml\`\n"
    printf -- "---\n"
    kubectl --context phxc -n smallstep get secret phxc-root -ojson | clean_cert_secret
    printf -- "---\n"
    kubectl --context phxc -n smallstep get secret phxc-intermediate -ojson | clean_cert_secret
    printf -- "---\n"
    kubectl --context phxc -n phxc get secret secureboot -ojson | clean_cert_secret
  )
  if [[ -n $dest ]]; then
    (umask 0077; printf "%s\n" "$backup" >"$dest")
  else
    printf "%s\n" "$backup"
  fi
}

restore_secrets() {
  local src=$1 backup
  if [[ -n $src ]]; then
    backup=$(cat "$src")
  else
    backup=$(cat)
  fi
  info "Restoring keys & certs"
  kubectl --context phxc apply -f <(printf "%s\n" "$backup")
  info "Restarting cluster services"
  kubectl --context phxc -n smallstep rollout restart statefulset phxc-ca
  kubectl --context phxc -n smallstep wait --timeout=-1s --for=condition=Ready=false pod phxc-ca-0
  kubectl --context phxc -n smallstep wait --timeout=-1s --for=condition=Ready pod phxc-ca-0
  kubectl --context phxc -n smallstep rollout restart deployment step-issuer
  info "Renewing all certificates that were issued by step-issuer"
  local ns cert secret
  while read -r -d $'\n' ns cert secret; do
    info "Renewing %s/%s" "$ns" "$cert"
    kubectl --context phxc -n "$ns" get secret "$secret" -ojson | \
      clean_cert_secret | \
      jq '.data["tls.crt"] |= "" | .data["ca.crt"] |= ""' | \
      kubectl apply -f -
    kubectl --context phxc -n "$ns" wait --timeout=-1s --for=condition=Ready certificate "$cert"
  done < <(kubectl get --all-namespaces certificate -ojson | \
    jq -r '.items[] | select(.spec.issuerRef == {"group": "certmanager.step.sm", "kind": "StepClusterIssuer", "name": "step-issuer"}) |
      .metadata.namespace + " " + .metadata.name + " " + .spec.secretName')
  kubectl --context phxc -n phxc rollout restart deployment image-registry
  info "Trusting new restored certificate on all nodes and resigning SSH host keys"
  local hostname
  for hostname in $(kubectl --context phxc get nodes -ojsonpath='{.items[*].metadata.labels.kubernetes\.io/hostname}'); do
    LC_ALL=C ssh -oStrictHostKeyChecking=accept-new "admin@$hostname" -- sudo systemctl restart --no-block workload-ready@smallstep workload-ready@image-registry trust-phxc-root sign-ssh-host-keys
  done
}

clean_cert_secret() {
  jq 'del(.metadata.annotations) | del(.metadata.labels) | del(.metadata.resourceVersion) | del(.metadata.uid)'
}

bootstrap() {
  local variant=$1 wait=$2 job_name
  job_name="build-$variant-$(date --utc +%Y%m%d%H%M%S)"
  info "Creating job %s" "$job_name"
  kubectl --context phxc -n phxc create job --from="cronjob/build-$variant" "$job_name"
  if $wait; then
    info "Waiting for %s to complete" "$job_name"
    kubectl --context phxc -n phxc wait --timeout=-1s --for=condition=Complete job "$job_name"
  fi
}

update_nodes() {
  local nodes=("$@") node hostname logpid start_time
  if ! kubectl get node -ojson | jq -e '.items[] | select(.spec.unschedulable) | length > 0' 2>&1 | LOGPROGRAM=step pipe_verbose; then
    fatal "Unable to update any nodes. Some nodes are currently unschedulable"
  fi
  for node in "${nodes[@]}"; do
    hostname=$(kubectl --context phxc get node "$node" -ojsonpath='{.metadata.labels.kubernetes\.io/hostname}')
    info "Updating %s" "$node"
    start_time=$(date "+%Y-%m-%d %H:%M:%S %z")
    LC_ALL=C ssh "admin@$hostname" -- sudo systemctl start --no-block update-boot
    LC_ALL=C ssh "admin@$hostname" -- journalctl -fu update-boot --since="\"$start_time\" --output=cat" & logpid=$!
    # shellcheck disable=SC2064
    trap "kill $logpid" EXIT
    LC_ALL=C ssh "admin@$node" -- bash -c '"while [[ $(systemctl show -p SubState --value update-boot) != dead ]]; do sleep 1; done"'
    kill $logpid
    trap "" EXIT
    # Node may be single master
    until kubectl --context phxc -n phxc wait --timeout=-1s --for=condition=Ready node "$node"; do
      info "Wait command failed, retrying in 10s (this may happen if the node that is updating is part of the control-plane)"
      sleep 10
    done
  done
}

main "$@"
